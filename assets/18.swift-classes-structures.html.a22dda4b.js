import{_ as o,r as i,o as c,c as p,a as s,b as n,d as a,e as t}from"./app.4659d0e0.js";const l={},d=t('<h1 id="swift基础-结构和类" tabindex="-1"><a class="header-anchor" href="#swift基础-结构和类" aria-hidden="true">#</a> Swift基础 - 结构和类</h1><p>翻译自：https://docs.swift.org/swift-book/LanguageGuide/ClassesAndStructures.html</p><p><em>结构</em>和<em>类</em>是通用的、灵活的结构，成为程序代码的构建块。您定义属性和方法，使用定义常量、变量和函数的相同语法为结构和类添加功能。</p><p>与其他编程语言不同，Swift不要求您为自定义结构和类创建单独的接口和实现文件。在Swift中，您在单个文件中定义结构或类，该类或结构的外部接口会自动供其他代码使用。</p><blockquote><p>注意</p><p>类的实例传统上被称为<em>对象</em>。然而，与其他语言相比，Swift结构和类的功能要接近得多，本章的大部分内容描述了适用于类或结构类型的实例的功能。因此，使用了更通用的术语<em>实例</em>。</p></blockquote><h2 id="比较结构和类" tabindex="-1"><a class="header-anchor" href="#比较结构和类" aria-hidden="true">#</a> 比较结构和类</h2><p>Swift中的结构和类有很多共同点。两者都可以：</p><ul><li>定义属性以存储值</li><li>定义提供功能的方法</li><li>定义下标，以使用下标语法提供对其值的访问</li><li>定义初始化器以设置其初始状态</li><li>扩展以将其功能扩展到默认实现之外</li><li>符合协议，提供某种类型的标准功能</li></ul>',8),r={href:"https://docs.swift.org/swift-book/LanguageGuide/Properties.html",target:"_blank",rel:"noopener noreferrer"},u={href:"https://docs.swift.org/swift-book/LanguageGuide/Methods.html",target:"_blank",rel:"noopener noreferrer"},m={href:"https://docs.swift.org/swift-book/LanguageGuide/Subscripts.html",target:"_blank",rel:"noopener noreferrer"},k={href:"https://docs.swift.org/swift-book/LanguageGuide/Initialization.html",target:"_blank",rel:"noopener noreferrer"},h={href:"https://docs.swift.org/swift-book/LanguageGuide/Extensions.html",target:"_blank",rel:"noopener noreferrer"},g={href:"https://docs.swift.org/swift-book/LanguageGuide/Protocols.html",target:"_blank",rel:"noopener noreferrer"},v=s("p",null,"类具有结构所没有的额外功能：",-1),f=s("ul",null,[s("li",null,"继承使一个类继承另一个类的特征。"),s("li",null,"类型转换使您可以在运行时检查和解释类实例的类型。"),s("li",null,"去初始化器使类的实例能够释放其分配的任何资源。"),s("li",null,"引用计数允许对类实例进行多个引用。")],-1),b={href:"https://docs.swift.org/swift-book/LanguageGuide/Inheritance.html",target:"_blank",rel:"noopener noreferrer"},w={href:"https://docs.swift.org/swift-book/LanguageGuide/TypeCasting.html",target:"_blank",rel:"noopener noreferrer"},_={href:"https://docs.swift.org/swift-book/LanguageGuide/Deinitialization.html",target:"_blank",rel:"noopener noreferrer"},y={href:"https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html",target:"_blank",rel:"noopener noreferrer"},q={href:"https://developer.apple.com/documentation/swift/choosing_between_structures_and_classes",target:"_blank",rel:"noopener noreferrer"},x=s("p",null,"注意",-1),E={href:"https://docs.swift.org/swift-book/LanguageGuide/Concurrency.html",target:"_blank",rel:"noopener noreferrer"},R=t(`<h3 id="定义语法" tabindex="-1"><a class="header-anchor" href="#定义语法" aria-hidden="true">#</a> 定义语法</h3><p>结构和类具有相似的定义语法。您引入了带有<code>struct</code>关键字的结构和带有<code>class</code>关键字的类。两者都将整个定义放在一对大括号中：</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">struct</span> <span class="token class-name">SomeStructure</span> <span class="token punctuation">{</span>
   <span class="token comment">// structure definition goes here</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">SomeClass</span> <span class="token punctuation">{</span>
   <span class="token comment">// class definition goes here</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><blockquote><p>注意</p><p>无论何时定义一个新的结构或类，都要定义一个新的Swift类型。给类型命名为‘UpperCamelCase’(比如这里的‘SomeStructure’和‘SomeClass’)，以匹配标准Swift类型(比如‘String’，‘Int’和‘Bool’)的大小写。将属性和方法命名为“lowerCamelCase”(例如“frameRate”和“incrementCount”)，以区别于类型名称。</p></blockquote><p>以下是结构定义和类定义的示例：</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">struct</span> <span class="token class-name">Resolution</span> <span class="token punctuation">{</span>
   <span class="token keyword">var</span> width <span class="token operator">=</span> <span class="token number">0</span>
   <span class="token keyword">var</span> height <span class="token operator">=</span> <span class="token number">0</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">VideoMode</span> <span class="token punctuation">{</span>
   <span class="token keyword">var</span> resolution <span class="token operator">=</span> <span class="token class-name">Resolution</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
   <span class="token keyword">var</span> interlaced <span class="token operator">=</span> <span class="token boolean">false</span>
   <span class="token keyword">var</span> frameRate <span class="token operator">=</span> <span class="token number">0.0</span>
   <span class="token keyword">var</span> name<span class="token punctuation">:</span> <span class="token class-name">String</span><span class="token operator">?</span>
<span class="token punctuation">}</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>上面的示例定义了一个名为<code>Resolution</code>的新结构，以描述基于像素的显示分辨率。这种结构有两个存储属性，称为<code>width</code>和<code>height</code>。存储属性是捆绑并作为结构或类的一部分存储的常量或变量。通过将这两个属性设置为初始整数值为<code>0</code>，可以推断为<code>Int</code>类型。</p><p>上面的示例还定义了一个名为<code>VideoMode</code>的新类，以描述视频显示的特定视频模式。该类有四个变量存储属性。第一个，<code>resolution</code>，用一个新的<code>Resolution</code>结构实例初始化，该实例推断出<code>Resolution</code>的属性类型。对于其他三个属性，新的<code>VideoMode</code>实例将初始化为<code>false</code>的<code>interlaced</code>设置（意思是“非隔行视频”），播放帧速率为<code>0.0</code>，以及名为<code>name</code>的可选<code>String</code>值。<code>name</code>属性会自动被赋予<code>nil</code>的默认值或“无<code>name</code>值”，因为它是可选类型。</p><h3 id="结构和类实例" tabindex="-1"><a class="header-anchor" href="#结构和类实例" aria-hidden="true">#</a> 结构和类实例</h3><p>&#39; Resolution &#39;结构定义和&#39; VideoMode &#39;类定义只描述了&#39; Resolution &#39;或&#39; VideoMode &#39;的外观。它们本身并不描述特定的分辨率或视频模式。为此，您需要创建结构或类的实例。</p><p>创建实例的语法对结构和类都非常相似：</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">let</span> someResolution <span class="token operator">=</span> <span class="token class-name">Resolution</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> someVideoMode <span class="token operator">=</span> <span class="token class-name">VideoMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div>`,12),V=s("code",null,"Resolution()",-1),M=s("code",null,"VideoMode()",-1),S={href:"https://docs.swift.org/swift-book/LanguageGuide/Initialization.html",target:"_blank",rel:"noopener noreferrer"},T=t(`<h3 id="访问属性" tabindex="-1"><a class="header-anchor" href="#访问属性" aria-hidden="true">#</a> 访问属性</h3><p>您可以使用<em>点语法</em>访问实例的属性。在点语法中，您立即在实例名称之后写入属性名称，用句点（<code>.</code>）分隔，没有任何空格：</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;The width of someResolution is </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">someResolution<span class="token punctuation">.</span>width</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
<span class="token comment">// Prints &quot;The width of someResolution is 0&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>在本例中，<code>someResolution.width</code>引用<code>someResolution</code>的<code>width</code>属性，并返回其默认初始值<code>0</code>。</p><p>您可以深入了解子属性，例如<code>VideoMode\`\`resolution</code>属性中的<code>width</code>属性：</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;The width of someVideoMode is </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">someVideoMode<span class="token punctuation">.</span>resolution<span class="token punctuation">.</span>width</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
<span class="token comment">// Prints &quot;The width of someVideoMode is 0&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>您还可以使用点语法为变量属性分配新值：</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code>someVideoMode<span class="token punctuation">.</span>resolution<span class="token punctuation">.</span>width <span class="token operator">=</span> <span class="token number">1280</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;The width of someVideoMode is now </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">someVideoMode<span class="token punctuation">.</span>resolution<span class="token punctuation">.</span>width</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
<span class="token comment">// Prints &quot;The width of someVideoMode is now 1280&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><h3 id="结构类型的成员初始化器" tabindex="-1"><a class="header-anchor" href="#结构类型的成员初始化器" aria-hidden="true">#</a> 结构类型的成员初始化器</h3><p>所有结构都有一个自动生成的<em>按成员初始化器</em>，您可以使用它初始化新结构实例的成员属性。新实例属性的初始值可以通过名称传递给成员初始化器：</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">let</span> vga <span class="token operator">=</span> <span class="token class-name">Resolution</span><span class="token punctuation">(</span>width<span class="token punctuation">:</span> <span class="token number">640</span><span class="token punctuation">,</span> height<span class="token punctuation">:</span> <span class="token number">480</span><span class="token punctuation">)</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div>`,11),C={href:"https://docs.swift.org/swift-book/LanguageGuide/Initialization.html",target:"_blank",rel:"noopener noreferrer"},L=t(`<h3 id="结构和枚举是值类型" tabindex="-1"><a class="header-anchor" href="#结构和枚举是值类型" aria-hidden="true">#</a> 结构和枚举是值类型</h3><p><em>值类型</em>是一种类型，其值在分配给变量或常量时，或当传递给函数时被<em>复制</em>。</p><p>在前几章中，您实际上一直在广泛使用值类型。事实上，Swift中的所有基本类型——整数、浮点数、布尔值、字符串、数组和字典——都是值类型，并作为幕后结构实现。</p><p>所有结构和枚举都是Swift中的值类型。这意味着，您创建的任何结构和枚举实例，以及它们作为属性的任何值类型，在代码中传递时，总是会被复制。</p><blockquote><p>注意</p><p>标准库定义的集合，如数组、字典和字符串，使用优化来降低复制的性能成本。这些集合不是立即复制，而是共享内存，其中元素存储在原始实例和任何副本之间。如果集合的副本之一被修改，则在修改前复制元素。您在代码中看到的行为总是像是立即复制一样。</p></blockquote><p>考虑这个例子，它使用上一个示例中的<code>Resolution</code>结构：</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">let</span> hd <span class="token operator">=</span> <span class="token class-name">Resolution</span><span class="token punctuation">(</span>width<span class="token punctuation">:</span> <span class="token number">1920</span><span class="token punctuation">,</span> height<span class="token punctuation">:</span> <span class="token number">1080</span><span class="token punctuation">)</span>
<span class="token keyword">var</span> cinema <span class="token operator">=</span> hd
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>此示例声明一个名为<code>hd</code>常量，并将其设置为使用全高清视频的宽度和高度初始化的<code>Resolution</code>实例（1920像素宽，高1080像素）。</p><p>然后，它声明一个名为<code>cinema</code>的变量，并将其设置为<code>hd</code>的当前值。因为<code>Resolution</code>是一个结构，所以制作了现有实例<em>的副本</em>，并将这个新副本分配给<code>cinema</code>。尽管<code>hd\`\`cinema</code>现在具有相同的宽度和高度，但它们是幕后两个完全不同的实例。</p><p>接下来，<code>cinema</code>的<code>width</code>属性被修改为用于数字影院投影的稍宽的2K标准的宽度（宽2048像素，高1080像素）：</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code>cinema<span class="token punctuation">.</span>width <span class="token operator">=</span> <span class="token number">2048</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div></div></div><p>检查<code>cinema</code>的<code>width</code>属性表明，它确实变成了<code>2048</code>：</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;cinema is now </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">cinema<span class="token punctuation">.</span>width</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string"> pixels wide&quot;</span></span><span class="token punctuation">)</span>
<span class="token comment">// Prints &quot;cinema is now 2048 pixels wide&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>然而，原始<code>hd</code>实例的<code>width</code>属性仍然具有<code>1920</code>年的旧值：</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;hd is still </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">hd<span class="token punctuation">.</span>width</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string"> pixels wide&quot;</span></span><span class="token punctuation">)</span>
<span class="token comment">// Prints &quot;hd is still 1920 pixels wide&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>当给<code>cinema</code>当前<code>hd</code>值时，存储在<code>hd</code>中的<em>值</em>被复制到新的<code>cinema</code>实例中。最终结果是两个完全独立的实例，其中包含相同的数字值。然而，由于它们是单独的实例，将<code>cinema</code>的宽度设置为<code>2048</code>不会影响存储在<code>hd</code>中的宽度，如下图所示：</p><p><img src="https://file.pandacode.cn/blog/202204051556030.png" alt="../_images/sharedStateStruct_2x.png"></p><p>同样的行为也适用于枚举：</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">enum</span> <span class="token class-name">CompassPoint</span> <span class="token punctuation">{</span>
   <span class="token keyword">case</span> north<span class="token punctuation">,</span> south<span class="token punctuation">,</span> east<span class="token punctuation">,</span> west
   <span class="token keyword">mutating</span> <span class="token keyword">func</span> <span class="token function-definition function">turnNorth</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
       <span class="token keyword">self</span> <span class="token operator">=</span> <span class="token punctuation">.</span>north
   <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> currentDirection <span class="token operator">=</span> <span class="token class-name">CompassPoint</span><span class="token punctuation">.</span>west
<span class="token keyword">let</span> rememberedDirection <span class="token operator">=</span> currentDirection
currentDirection<span class="token punctuation">.</span><span class="token function">turnNorth</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;The current direction is </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">currentDirection</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
<span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;The remembered direction is </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">rememberedDirection</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
<span class="token comment">// Prints &quot;The current direction is north&quot;</span>
<span class="token comment">// Prints &quot;The remembered direction is west&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>当<code>rememberedDirection</code>被分配到<code>currentDirection</code>的值时，它实际上被设置为该值的副本。此后更改<code>currentDirection</code>的值不会影响存储在<code>rememberedDirection</code>中的原始值的副本。</p><h2 id="类是参考类型" tabindex="-1"><a class="header-anchor" href="#类是参考类型" aria-hidden="true">#</a> 类是参考类型</h2><p>与值类型不同，<em>引用类型</em>在分配给变量或常量或传递给函数时<em>不会</em>复制。使用对相同现有实例的引用，而不是副本。</p><p>以下是使用上面定义的<code>VideoMode</code>类的示例：</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">let</span> tenEighty <span class="token operator">=</span> <span class="token class-name">VideoMode</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
tenEighty<span class="token punctuation">.</span>resolution <span class="token operator">=</span> hd
tenEighty<span class="token punctuation">.</span>interlaced <span class="token operator">=</span> <span class="token boolean">true</span>
tenEighty<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string-literal"><span class="token string">&quot;1080i&quot;</span></span>
tenEighty<span class="token punctuation">.</span>frameRate <span class="token operator">=</span> <span class="token number">25.0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子声明了一个名为&#39; ten80 &#39;的新常量，并将其设置为指向&#39; VideoMode &#39;类的一个新实例。视频模式被分配一个以前的高清分辨率“1920”到“1080”的副本。它被设置为交错，它的名称被设置为‘1080i’，它的帧速率被设置为‘25.0’帧每秒。</p><p>接下来，<code>tenEighty</code>分配给一个新的常量，称为<code>alsoTenEighty</code>，并修改了<code>alsoTenEighty</code>帧速率：</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">let</span> alsoTenEighty <span class="token operator">=</span> tenEighty
alsoTenEighty<span class="token punctuation">.</span>frameRate <span class="token operator">=</span> <span class="token number">30.0</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>由于类是引用类型，<code>tenEighty</code>和<code>alsoTenEighty</code>实际上都引用<em>同一个</em><code>VideoMode</code>实例。实际上，它们只是同一单个实例的两个不同名称，如下图所示：</p><p><img src="https://file.pandacode.cn/blog/202204051557330.png" alt="../_images/sharedStateClass_2x.png"></p><p>检查<code>tenEighty</code>的<code>frameRate</code>属性表明，它从底层<code>VideoMode</code>实例正确报告了<code>30.0</code>的新帧速率：</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;The frameRate property of tenEighty is now </span><span class="token interpolation-punctuation punctuation">\\(</span><span class="token interpolation">tenEighty<span class="token punctuation">.</span>frameRate</span><span class="token interpolation-punctuation punctuation">)</span><span class="token string">&quot;</span></span><span class="token punctuation">)</span>
<span class="token comment">// Prints &quot;The frameRate property of tenEighty is now 30.0&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div></div></div><p>这个例子还展示了引用类型如何更难推理。如果<code>tenEighty</code>和<code>alsoTenEighty</code>程序的代码中相距甚远，可能很难找到更改视频模式的所有方式。无论你在哪里使用<code>tenEighty</code>，你还必须考虑使用<code>alsoTenEighty</code>的代码，反之亦然。相比之下，值类型更容易推理，因为所有与相同值交互的代码都在源文件中紧密相连。</p><p>请注意，<code>tenEighty</code>和<code>alsoTenEighty</code>被声明为<em>常量</em>，而不是变量。但是，您仍然可以更改<code>tenEighty.frameRate</code>和<code>alsoTenEighty.frameRate</code>，因为<code>tenEighty</code>和<code>alsoTenEighty</code>常量本身的值实际上没有变化。<code>tenEighty</code>和<code>alsoTenEighty</code>本身不会“存储”<code>VideoMode</code>实例，相反，它们都<em>指</em>幕后<code>VideoMode</code>实例。更改的是底层<code>VideoMode</code>的<code>frameRate</code>属性，而不是对该<code>VideoMode</code>的常量引用的值。</p><h3 id="身份运算符" tabindex="-1"><a class="header-anchor" href="#身份运算符" aria-hidden="true">#</a> 身份运算符</h3><p>由于类是引用类型，因此多个常量和变量可以在幕后引用类的同一单个实例。（结构和枚举并非如此，因为它们在分配给常量或变量或传递给函数时总是被复制。）</p><p>有时，找出两个常量或变量是否引用一个类的完全相同的实例是有用的。为了实现这一点，Swift提供了两个身份运算符：</p><ul><li>相同到（<code>===</code>)</li><li>Not identical to (<code>!==</code>)</li></ul><p>使用这些运算符检查两个常量或变量是否引用同一个实例：</p><div class="language-swift line-numbers-mode" data-ext="swift"><pre class="language-swift"><code><span class="token keyword">if</span> tenEighty <span class="token operator">===</span> alsoTenEighty <span class="token punctuation">{</span>
   <span class="token function">print</span><span class="token punctuation">(</span><span class="token string-literal"><span class="token string">&quot;tenEighty and alsoTenEighty refer to the same VideoMode instance.&quot;</span></span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">// Prints &quot;tenEighty and alsoTenEighty refer to the same VideoMode instance.&quot;</span>
</code></pre><div class="line-numbers" aria-hidden="true"><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div><div class="line-number"></div></div></div><p>请注意，<em>相同于</em>（由三个相等符号表示，或<code>===</code>并不意味着<em>等于</em>（由两个相等符号表示，或<code>==</code>相同。<em>与</em>类类型的两个常量或变量引用完全相同的类实例相同。<em>等于</em>意味着两个实例在值上被认为是相等或等价的，对于类型设计器定义的<em>相等</em>的适当含义。</p>`,40),G=s("code",null,"==",-1),P=s("code",null,"!=",-1),D={href:"https://docs.swift.org/swift-book/LanguageGuide/AdvancedOperators.html#ID45",target:"_blank",rel:"noopener noreferrer"},I=s("h3",{id:"指针",tabindex:"-1"},[s("a",{class:"header-anchor",href:"#指针","aria-hidden":"true"},"#"),n(" 指针")],-1),N=s("em",null,"指针",-1),z=s("code",null,"*",-1),B={href:"https://developer.apple.com/documentation/swift/swift_standard_library/manual_memory_management",target:"_blank",rel:"noopener noreferrer"};function A(O,j){const e=i("ExternalLinkIcon");return c(),p("div",null,[d,s("p",null,[n("有关更多信息，请参阅"),s("a",r,[n("属性"),a(e)]),n("、"),s("a",u,[n("方法"),a(e)]),n("、"),s("a",m,[n("下标"),a(e)]),n("、"),s("a",k,[n("初始化"),a(e)]),n("、"),s("a",h,[n("扩展"),a(e)]),n("和"),s("a",g,[n("协议"),a(e)]),n("。")]),v,f,s("p",null,[n("有关更多信息，请参阅"),s("a",b,[n("继承"),a(e)]),n("、"),s("a",w,[n("类型铸造"),a(e)]),n("、"),s("a",_,[n("去初始化"),a(e)]),n("和"),s("a",y,[n("自动引用计数"),a(e)]),n("。")]),s("p",null,[n("类支持的额外功能以增加复杂性为代价。作为一般准则，更喜欢结构，因为它们更容易推理，并在适当或必要时使用类。在实践中，这意味着您定义的大多数自定义数据类型将是结构和枚举。有关更详细的比较，请参阅"),s("a",q,[n("在结构和类之间进行选择"),a(e)]),n("。")]),s("blockquote",null,[x,s("p",null,[n("班级和演员有许多相同的特征和行为。有关演员的信息，请参阅"),s("a",E,[n("并发"),a(e)]),n("。")])]),R,s("p",null,[n("结构和类都对新实例使用初始化器语法。最简单的初始化器语法形式使用类或结构的类型名称，后跟空括号，如"),V,n("或"),M,n("。这会创建一个类或结构的新实例，任何属性都初始化为默认值。类和结构初始化在"),s("a",S,[n("初始化"),a(e)]),n("中进行了更详细的描述。")]),T,s("p",null,[n("与结构不同，类实例不会收到默认的按成员初始化器。初始化器在"),s("a",C,[n("初始化"),a(e)]),n("中进行了更详细的描述。")]),L,s("p",null,[n("当您定义自己的自定义结构和类时，您有责任决定什么符合两个相等的条件。定义自己实现"),G,n("和的过程"),P,n("运算符在"),s("a",D,[n("等效运算符"),a(e)]),n("中描述。")]),I,s("p",null,[n("如果您有使用C、C++或Objective-C的经验，您可能知道这些语言使用"),N,n("来引用内存中的地址。引用某些引用类型的实例的Swift常量或变量类似于C中的指针，但不是指向内存中地址的直接指针，并且不需要您编写星号（"),z,n("）来指示您正在创建引用。相反，这些引用的定义与Swift中的任何其他常量或变量一样。标准库提供了指针和缓冲区类型，如果您需要直接与指针交互，您可以使用这些类型，请参阅"),s("a",B,[n("手动内存管理"),a(e)]),n("。")])])}const U=o(l,[["render",A],["__file","18.swift-classes-structures.html.vue"]]);export{U as default};
