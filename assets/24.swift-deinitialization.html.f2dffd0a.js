import{_ as t,r as l,o as c,c as a,a as i,b as e,d as s,e as o}from"./app.4659d0e0.js";const r={},d=o('<h1 id="swift基础-去初始化" tabindex="-1"><a class="header-anchor" href="#swift基础-去初始化" aria-hidden="true">#</a> Swift基础 - 去初始化</h1><p>翻译自：https://docs.swift.org/swift-book/LanguageGuide/Deinitialization.html</p><p>在类实例被释放之前，会立即调用<em>去初始化器</em>。您使用<code>deinit</code>关键字编写去初始化器，类似于使用<code>init</code>关键字编写初始化器的方式。取消初始化器仅适用于类类型。</p><h2 id="deinitialization如何运作" tabindex="-1"><a class="header-anchor" href="#deinitialization如何运作" aria-hidden="true">#</a> Deinitialization如何运作</h2>',4),u=i("em",null,"自动引用计数",-1),p=i("em",null,"ARC",-1),h={href:"https://docs.swift.org/swift-book/LanguageGuide/AutomaticReferenceCounting.html",target:"_blank",rel:"noopener noreferrer"},f=o('<p>类定义每个类最多可以有一个去初始化器。取消初始化器不接受任何参数，并且没有括号：</p><ol><li>deinit {</li><li>​ // perform the deinitialization</li><li>}</li></ol><p>在实例处理分配发生之前，会自动调用去初始化器。您不得自己调用非初始化器。超类非初始化器由其子类继承，超类非初始化器在子类非初始化器实现结束时自动调用。总是调用超类非初始化器，即使子类不提供自己的非初始化器。</p><p>由于实例在调用其非初始化器后才会被释放，因此非初始化器可以访问其调用的实例的所有属性，并可以根据这些属性修改其行为（例如查找需要关闭的文件的名称）。</p><h2 id="去初始化器在行动" tabindex="-1"><a class="header-anchor" href="#去初始化器在行动" aria-hidden="true">#</a> 去初始化器在行动</h2><p>以下是一个非初始化器在起作用的例子。这个例子为一个简单的游戏定义了两种新类型，<code>Bank</code>和<code>Player</code>。<code>Bank</code>级管理一种制成币，流通量永远不会超过10,000枚硬币。游戏中只能有一个<code>Bank</code>，因此该<code>Bank</code>是一个具有类型属性和方法来存储和管理其当前状态的类实现：</p><ol><li>class Bank {</li><li>​ static var coinsInBank = 10_000</li><li>​ static func distribute(coins numberOfCoinsRequested: Int) -&gt; Int {</li><li>​ let numberOfCoinsToVend = min(numberOfCoinsRequested, coinsInBank)</li><li>​ coinsInBank -= numberOfCoinsToVend</li><li>​ return numberOfCoinsToVend</li><li>​ }</li><li>​ static func receive(coins: Int) {</li><li>​ coinsInBank += coins</li><li>​ }</li><li>}</li></ol><p><code>Bank</code> keeps track of the current number of coins it holds with its <code>coinsInBank</code> property. It also offers two methods—<code>distribute(coins:)</code> and <code>receive(coins:)</code>—to handle the distribution and collection of coins.</p><p><code>distribute(coins:)</code>方法在分发硬币之前检查银行中是否有足够的硬币。如果硬币不够，<code>Bank</code>返回的数字比请求的数字要小（如果银行中没有硬币，则返回零）。它返回一个整数值，以指示提供的实际硬币数量。</p><p><code>receive(coins:)</code>方法只需将收到的硬币数量重新添加到银行的硬币商店。</p><p><code>Player</code>类描述了游戏中的玩家。每个玩家的钱包里随时都有一定数量的硬币。这由玩家的<code>coinsInPurse</code>属性表示：</p><ol><li>class Player {</li><li>​ var coinsInPurse: Int</li><li>​ init(coins: Int) {</li><li>​ coinsInPurse = Bank.distribute(coins: coins)</li><li>​ }</li><li>​ func win(coins: Int) {</li><li>​ coinsInPurse += Bank.distribute(coins: coins)</li><li>​ }</li><li>​ deinit {</li><li>​ Bank.receive(coins: coinsInPurse)</li><li>​ }</li><li>}</li></ol><p>在初始化期间，每个<code>Player</code>实例都使用银行指定数量的硬币的起始限额进行初始化，尽管如果没有足够的硬币可用，<code>Player</code>实例收到的硬币可能少于该数字。</p><p><code>Player</code>类定义了一个<code>win(coins:)</code>方法，该方法从银行检索一定数量的硬币并将其添加到玩家的钱包中。<code>Player</code>类还实现了去初始化器，该去初始化器是在<code>Player</code>实例被释放之前调用的。在这里，去初始化器只需将玩家的所有硬币退还给银行：</p><ol><li>var playerOne: Player? = Player(coins: 100)</li><li>print(&quot;A new player has joined the game with (playerOne!.coinsInPurse) coins&quot;)</li><li>// Prints &quot;A new player has joined the game with 100 coins&quot;</li><li>print(&quot;There are now (Bank.coinsInBank) coins left in the bank&quot;)</li><li>// Prints &quot;There are now 9900 coins left in the bank&quot;</li></ol><p>创建一个新的<code>Player</code>实例，如果有的话，需要100枚硬币。此<code>Player</code>实例存储在名为<code>playerOne</code>的可选<code>Player</code>变量中。这里使用可选变量，因为玩家可以随时离开游戏。可选功能允许您跟踪游戏中目前是否有玩家。</p><p>因为<code>playerOne</code>是可选的，所以它有资格获得感叹号（<code>!</code>）当访问itscoinsInPurse属性以打印其默认硬币数量时，以及每当调用itswin<code>win(coins:)</code>方法时：</p><ol><li>playerOne!.win(coins: 2_000)</li><li>print(&quot;PlayerOne won 2000 coins &amp; now has (playerOne!.coinsInPurse) coins&quot;)</li><li>// Prints &quot;PlayerOne won 2000 coins &amp; now has 2100 coins&quot;</li><li>print(&quot;The bank now only has (Bank.coinsInBank) coins left&quot;)</li><li>// Prints &quot;The bank now only has 7900 coins left&quot;</li></ol><p>在这里，玩家赢得了2000枚硬币。玩家的钱包现在包含2100枚硬币，而银行只剩下7900枚硬币。</p><ol><li>playerOne = nil</li><li>print(&quot;PlayerOne has left the game&quot;)</li><li>// Prints &quot;PlayerOne has left the game&quot;</li><li>print(&quot;The bank now has (Bank.coinsInBank) coins&quot;)</li><li>// Prints &quot;The bank now has 10000 coins&quot;</li></ol><p>玩家现在已经离开了游戏。这通过将可选的<code>playerOne</code>变量设置为<code>nil</code>来指示，这意味着“没有<code>Player</code>实例”。发生这种情况时，<code>playerOne</code>变量对<code>Player</code>实例的引用被破坏。没有其他属性或变量仍然引用<code>Player</code>实例，因此将其释放以释放其内存。就在这种情况发生之前，其去初始化器会自动调用，其硬币被退回银行。</p>',21);function k(y,P){const n=l("ExternalLinkIcon");return c(),a("div",null,[d,i("p",null,[e("Swift 会在不再需要实例时自动处理这些实例，以释放资源。Swift通过"),u,e("（"),p,e("）处理实例的内存管理，如"),i("a",h,[e("自动引用计数"),s(n)]),e("中所述。通常，在实例被释放时，您不需要进行手动清理。但是，当您使用自己的资源时，您可能需要自己进行一些额外的清理。例如，如果您创建一个自定义类来打开文件并向其写入一些数据，您可能需要在类实例被释放之前关闭文件。")]),f])}const m=t(r,[["render",k],["__file","24.swift-deinitialization.html.vue"]]);export{m as default};
