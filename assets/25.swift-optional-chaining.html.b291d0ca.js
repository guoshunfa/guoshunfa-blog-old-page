import{_ as l,r as n,o as c,c as s,a as o,b as e,d as t,e as i}from"./app.4659d0e0.js";const r={},a=i('<h1 id="swift基础-可选链条" tabindex="-1"><a class="header-anchor" href="#swift基础-可选链条" aria-hidden="true">#</a> Swift基础 - 可选链条</h1><p>翻译自：https://docs.swift.org/swift-book/LanguageGuide/OptionalChaining.html</p><p><em>可选链</em>是一个在当前可能为<code>nil</code>的可选<em>链</em>上查询和调用属性、方法和下标的过程。如果可选包含值，则属性、方法或下标调用成功；如果可选值为<code>nil</code>，则属性、方法或下标调用返回<code>nil</code>。多个查询可以链接在一起，如果链中的任何链接为<code>nil</code>整个链条会优雅地失败。</p><p>注意</p><p>Swift中的可选链类似于Objective-C中的消息<code>nil</code>，但以适用于任何类型的方式，并且可以检查成功或失败。</p><h2 id="可选链作为强制打开包装的替代方案" tabindex="-1"><a class="header-anchor" href="#可选链作为强制打开包装的替代方案" aria-hidden="true">#</a> 可选链作为强制打开包装的替代方案</h2><p>您通过放置问号（<code>?</code>）来指定可选的链条在可选值之后，如果可选值为非<code>nil</code>在您希望调用属性、方法或下标的可选值之后。这与放置感叹号（<code>!</code>）非常相似在可选值之后，强制展开其值。主要区别在于，当可选链接为<code>nil</code>，可选链会优雅地失败，而当可选链接为<code>nil</code>，强制展开包装会触发运行时错误。</p><p>为了反映可选链可以在<code>nil</code>值上调用的事实，可选链调用的结果始终是可选值，即使您正在查询的属性、方法或下标返回非可选值。您可以使用此可选返回值来检查可选链调用是否成功（返回的可选包含值），还是由于链中的<code>nil</code>值而没有成功（返回的可选值为<code>nil</code>）。</p><p>具体来说，可选链调用的结果与预期返回值类型相同，但包装在可选中。通常返回<code>Int</code>的属性会返回<code>Int?</code>通过可选链访问时。</p><p>接下来的几个代码片段演示了可选链与强制拆开的区别，并使您能够检查成功。</p><p>First, two classes called <code>Person</code> and <code>Residence</code> are defined:</p><ol><li>class Person {</li><li>​ var residence: Residence?</li><li>}</li><li></li><li>class Residence {</li><li>​ var numberOfRooms = 1</li><li>}</li></ol><p><code>Residence</code>实例有一个名为<code>numberOfRooms``Int</code>属性，默认值为1。<code>Person</code>实例具有<code>Residence?</code>类型为可选的<code>residence</code>属性。</p><p>如果您创建一个新的<code>Person</code>实例，其<code>residence</code>属性默认初始化为<code>nil</code>，因为它是可选的。在下面的代码中，<code>john</code>的<code>residence</code>物业价值为<code>nil</code>：</p><ol><li>let john = Person()</li></ol><p>如果您尝试访问此人<code>residence</code>的<code>numberOfRooms</code>属性，通过在<code>residence</code>后放置感叹号以强制解开其值，您将触发运行时错误，因为没有<code>residence</code>值可以打开：</p><ol><li>let roomCount = john.residence!.numberOfRooms</li><li>// this triggers a runtime error</li></ol><p><code>john.residence</code>具有非<code>nil</code>值时，上述代码将成功，并将<code>roomCount</code>设置为包含适当数量房间的<code>Int</code>值。然而，如上所述，当<code>residence</code>为<code>nil</code>，此代码总是触发运行时错误。</p><p>可选链提供了一种访问<code>numberOfRooms</code>值的替代方式。要使用可选的链条，请使用问号代替感叹号：</p><ol><li>if let roomCount = john.residence?.numberOfRooms {</li><li>​ print(&quot;John&#39;s residence has (roomCount) room(s).&quot;)</li><li>} else {</li><li>​ print(&quot;Unable to retrieve the number of rooms.&quot;)</li><li>}</li><li>// Prints &quot;Unable to retrieve the number of rooms.&quot;</li></ol><p>这告诉Swift在可选的<code>residence</code>属性上“链”，如果存在<code>residence</code>，则检索<code>numberOfRooms</code>值。</p><p>由于访问<code>numberOfRooms</code>尝试可能会失败，因此可选的链式尝试返回类型为<code>Int?</code>或“optional <code>Int</code>”的值。如上例所示，当<code>residence</code>为<code>nil</code>，此可选的<code>Int</code>也将为<code>nil</code>，以反映无法访问<code>numberOfRooms</code>的事实。可选的<code>Int</code>通过可选绑定访问，以解开整数，并将非可选值分配给<code>roomCount</code>常量。</p><p>请注意，即使<code>numberOfRooms</code>是一个非可选的<code>Int</code>也是如此。它通过可选链查询的事实意味着对<code>numberOfRooms</code>调用将始终返回anInt<code>Int?</code>而不是<code>Int</code>。</p><p>您可以将<code>Residence</code>实例分配给<code>john.residence</code>，使其不再具有<code>nil</code>值：</p><ol><li>john.residence = Residence()</li></ol><p><code>john.residence</code>现在包含一个实际的<code>Residence</code>实例，而不是<code>nil</code>。如果您尝试使用与以前相同的可选链条访问<code>numberOfRooms</code>，它现在将返回一个<code>Int?</code>包含默认<code>numberOfRooms</code>值为1：</p><ol><li>if let roomCount = john.residence?.numberOfRooms {</li><li>​ print(&quot;John&#39;s residence has (roomCount) room(s).&quot;)</li><li>} else {</li><li>​ print(&quot;Unable to retrieve the number of rooms.&quot;)</li><li>}</li><li>// Prints &quot;John&#39;s residence has 1 room(s).&quot;</li></ol><h2 id="定义可选链的模型类" tabindex="-1"><a class="header-anchor" href="#定义可选链的模型类" aria-hidden="true">#</a> 定义可选链的模型类</h2><p>您可以使用可选链来调用多个级别深的属性、方法和下标。这使您能够深入了解相互关联的复杂模型中的子属性，并检查是否可以访问这些子属性的属性、方法和下标。</p><p>下面的代码片段定义了四个模型类，用于后续几个示例，包括多级可选链的示例。这些类通过添加<code>Room</code>和<code>Address</code>类以及相关的属性、方法和下标来扩展上面的<code>Person``Residence</code>模式。</p><p><code>Person</code>类的定义与以前相同：</p><ol><li>class Person {</li><li>​ var residence: Residence?</li><li>}</li></ol><p><code>Residence</code>舱比以前更复杂。这一次，<code>Residence</code>类定义了一个名为<code>rooms</code>的变量属性，该属性使用<code>[Room]</code>类型的空数组初始化：</p><ol><li>class Residence {</li><li>​ var rooms: [Room] = []</li><li>​ var numberOfRooms: Int {</li><li>​ return rooms.count</li><li>​ }</li><li>​ subscript(i: Int) -&gt; Room {</li><li>​ get {</li><li>​ return rooms[i]</li><li>​ }</li><li>​ set {</li><li>​ rooms[i] = newValue</li><li>​ }</li><li>​ }</li><li>​ func printNumberOfRooms() {</li><li>​ print(&quot;The number of rooms is (numberOfRooms)&quot;)</li><li>​ }</li><li>​ var address: Address?</li><li>}</li></ol><p>由于此版本的<code>Residence</code>存储了一个<code>Room</code>实例数组，因此其<code>numberOfRooms</code>属性作为计算属性实现，而不是存储属性。computednumberOfRooms属性只需从<code>rooms</code>数组返回<code>count</code>属性的值。</p><p>作为访问其<code>rooms</code>数组的快捷方式，此版本的<code>Residence</code>提供了一个读写下标，该下标可根据<code>rooms</code>数组中请求的索引访问房间。</p><p>这个版本的<code>Residence</code>还提供了一种名为<code>printNumberOfRooms</code>的方法，它只需打印住宅中的房间数量。</p><p>Finally, <code>Residence</code> defines an optional property called <code>address</code>, with a type of <code>Address?</code>. The <code>Address</code> class type for this property is defined below.</p><p>用于<code>rooms</code>数组的<code>Room</code>类是一个简单的类，有一个名为<code>name</code>的属性，以及将该属性设置为合适房间名称的初始化器：</p><ol><li>class Room {</li><li>​ let name: String</li><li>​ init(name: String) { self.name = name }</li><li>}</li></ol><p>这个模型中的最后一个类称为<code>Address</code>。该类有三个typeString<code>String?</code>的可选属性。前两个属性，<code>buildingName</code>和<code>buildingNumber</code>，是将特定建筑物识别为地址一部分的替代方法。第三种财产，<code>street</code>，用于为该地址命名街道：</p><ol><li>class Address {</li><li>​ var buildingName: String?</li><li>​ var buildingNumber: String?</li><li>​ var street: String?</li><li>​ func buildingIdentifier() -&gt; String? {</li><li>​ if let buildingNumber = buildingNumber, let street = street {</li><li>​ return &quot;(buildingNumber) (street)&quot;</li><li>​ } else if buildingName != nil {</li><li>​ return buildingName</li><li>​ } else {</li><li>​ return nil</li><li>​ }</li><li>​ }</li><li>}</li></ol><p>The <code>Address</code> class also provides a method called <code>buildingIdentifier()</code>, which has a return type of <code>String?</code>. This method checks the properties of the address and returns <code>buildingName</code> if it has a value, or <code>buildingNumber</code> concatenated with <code>street</code> if both have values, or <code>nil</code> otherwise.</p><h2 id="通过可选链访问属性" tabindex="-1"><a class="header-anchor" href="#通过可选链访问属性" aria-hidden="true">#</a> 通过可选链访问属性</h2>',44),u={href:"https://docs.swift.org/swift-book/LanguageGuide/OptionalChaining.html#ID246",target:"_blank",rel:"noopener noreferrer"},h=i('<p>使用上面定义的类创建一个新的<code>Person</code>实例，并尝试像以前一样访问其<code>numberOfRooms</code>属性：</p><ol><li>let john = Person()</li><li>if let roomCount = john.residence?.numberOfRooms {</li><li>​ print(&quot;John&#39;s residence has (roomCount) room(s).&quot;)</li><li>} else {</li><li>​ print(&quot;Unable to retrieve the number of rooms.&quot;)</li><li>}</li><li>// Prints &quot;Unable to retrieve the number of rooms.&quot;</li></ol><p>由于<code>john.residence</code>为<code>nil</code>，这个可选的链式调用与以前一样失败。</p><p>您还可以尝试通过可选链设置属性的值：</p><ol><li>let someAddress = Address()</li><li>someAddress.buildingNumber = &quot;29&quot;</li><li>someAddress.street = &quot;Acacia Road&quot;</li><li>john.residence?.address = someAddress</li></ol><p>在本例中，设置<code>john.residence``address</code>属性的尝试将失败，因为<code>john.residence</code>目前为<code>nil</code>。</p><p>该赋值是可选链的一部分，这意味着没有计算<code>=</code>运算符右侧的代码。在上一个示例中，不容易看到<code>someAddress</code>从未被评估过，因为访问常量没有任何副作用。以下列表执行相同的分配，但它使用函数来创建地址。该函数在返回值之前打印“函数已调用”，该值允许您查看是否计算了<code>=</code>运算符的右侧。</p><ol><li>func createAddress() -&gt; Address {</li><li>​ print(&quot;Function was called.&quot;)</li><li></li><li>​ let someAddress = Address()</li><li>​ someAddress.buildingNumber = &quot;29&quot;</li><li>​ someAddress.street = &quot;Acacia Road&quot;</li><li></li><li>​ return someAddress</li><li>}</li><li>john.residence?.address = createAddress()</li></ol><p>您可以判断没有调用<code>createAddress()</code>函数，因为没有打印任何东西。</p><h2 id="通过可选链调用方法" tabindex="-1"><a class="header-anchor" href="#通过可选链调用方法" aria-hidden="true">#</a> 通过可选链调用方法</h2><p>您可以使用可选链调用可选值上的方法，并检查该方法调用是否成功。即使该方法没有定义返回值，您也可以这样做。</p><p><code>Residence</code>类上的<code>printNumberOfRooms()</code>方法打印<code>numberOfRooms</code>当前值。以下是方法的外观：</p><ol><li>func printNumberOfRooms() {</li><li>​ print(&quot;The number of rooms is (numberOfRooms)&quot;)</li><li>}</li></ol>',13),m=o("code",null,"Void",-1),p={href:"https://docs.swift.org/swift-book/LanguageGuide/Functions.html#ID163",target:"_blank",rel:"noopener noreferrer"},f=o("code",null,"()",-1),b=i("<p>If you call this method on an optional value with optional chaining, the method’s return type will be <code>Void?</code>, not <code>Void</code>, because return values are always of an optional type when called through optional chaining. This enables you to use an <code>if</code> statement to check whether it was possible to call the <code>printNumberOfRooms()</code> method, even though the method doesn’t itself define a return value. Compare the return value from the <code>printNumberOfRooms</code> call against <code>nil</code> to see if the method call was successful:</p><ol><li>if john.residence?.printNumberOfRooms() != nil {</li><li>​ print(&quot;It was possible to print the number of rooms.&quot;)</li><li>} else {</li><li>​ print(&quot;It was not possible to print the number of rooms.&quot;)</li><li>}</li><li>// Prints &quot;It was not possible to print the number of rooms.&quot;</li></ol>",2),q={href:"https://docs.swift.org/swift-book/LanguageGuide/OptionalChaining.html#ID248",target:"_blank",rel:"noopener noreferrer"},g=o("code",null,"john.residence",-1),R=o("code",null,"address",-1),j=o("code",null,"residence",-1),v=o("code",null,"nil",-1),_=o("code",null,"Void?",-1),w=o("code",null,"nil",-1),I=i('<ol><li>if (john.residence?.address = someAddress) != nil {</li><li>​ print(&quot;It was possible to set the address.&quot;)</li><li>} else {</li><li>​ print(&quot;It was not possible to set the address.&quot;)</li><li>}</li><li>// Prints &quot;It was not possible to set the address.&quot;</li></ol><h2 id="通过可选链条访问下标" tabindex="-1"><a class="header-anchor" href="#通过可选链条访问下标" aria-hidden="true">#</a> 通过可选链条访问下标</h2><p>您可以使用可选链尝试从可选值的下标中检索和设置值，并检查该下标调用是否成功。</p><p>注意</p><p>当您通过可选链访问可选值的下标时，您将问号放在下标括号<em>之前</em>，而不是之后。可选的链式问号总是紧随其后于表达式的可选部分之后。</p><p>下面的示例试图使用<code>Residence</code>类上定义的下标检索<code>john.residence</code>属性的<code>rooms</code>数组中第一个房间的名称。由于<code>john.residence</code>目前为<code>nil</code>，下标调用失败：</p><ol><li>if let firstRoomName = john.residence?[0].name {</li><li>​ print(&quot;The first room name is (firstRoomName).&quot;)</li><li>} else {</li><li>​ print(&quot;Unable to retrieve the first room name.&quot;)</li><li>}</li><li>// Prints &quot;Unable to retrieve the first room name.&quot;</li></ol><p>此下标调用中的可选链问号立即放在<code>john.residence</code>之后的下标括号之前，因为<code>john.residence</code>是尝试可选链的可选值。</p><p>同样，您可以尝试通过带有可选链的下标设置新值：</p><ol><li>john.residence?[0] = Room(name: &quot;Bathroom&quot;)</li></ol><p>此下标设置尝试也失败，因为<code>residence</code>目前为<code>nil</code>。</p><p>如果您创建并向<code>john.residence</code>分配实际的<code>Residence</code>实例，其<code>rooms</code>数组中有一个或多个<code>Room</code>实例，您可以使用<code>Residence</code>下标通过可选链访问<code>rooms</code>数组中的实际项目：</p><ol><li>let johnsHouse = Residence()</li><li>johnsHouse.rooms.append(Room(name: &quot;Living Room&quot;))</li><li>johnsHouse.rooms.append(Room(name: &quot;Kitchen&quot;))</li><li>john.residence = johnsHouse</li><li></li><li>if let firstRoomName = john.residence?[0].name {</li><li>​ print(&quot;The first room name is (firstRoomName).&quot;)</li><li>} else {</li><li>​ print(&quot;Unable to retrieve the first room name.&quot;)</li><li>}</li><li>// Prints &quot;The first room name is Living Room.&quot;</li></ol><h3 id="访问可选类型的下标" tabindex="-1"><a class="header-anchor" href="#访问可选类型的下标" aria-hidden="true">#</a> 访问可选类型的下标</h3><p>如果下标返回可选类型的值（例如Swift&#39;sDictionary类型的键下标），请在下标的闭括号<em>后</em>放置一个问号，以链式链接到其可选返回值：</p><ol><li>var testScores = [&quot;Dave&quot;: [86, 82, 84], &quot;Bev&quot;: [79, 94, 81]]</li><li>testScores[&quot;Dave&quot;]?[0] = 91</li><li>testScores[&quot;Bev&quot;]?[0] += 1</li><li>testScores[&quot;Brian&quot;]?[0] = 72</li><li>// the &quot;Dave&quot; array is now [91, 82, 84] and the &quot;Bev&quot; array is now [80, 94, 81]</li></ol><p>上面的示例定义了一个名为<code>testScores</code>字典，其中包含两个键值对，将<code>String</code>键映射到<code>Int</code>值数组。该示例使用可选链将<code>&quot;Dave&quot;</code>数组中的第一个项目设置为<code>91</code>；将<code>&quot;Bev&quot;</code>数组中的第一个项目增加<code>1</code>；并尝试将数组中的第一个项目设置为<code>&quot;Brian&quot;</code>的键。前两个调用成功了，因为<code>testScores</code>字典包含<code>&quot;Dave&quot;</code>和<code>&quot;Bev&quot;</code>的键。第三次调用失败，因为<code>testScores</code>字典不包含<code>&quot;Brian&quot;</code>的密钥。</p><h2 id="连接多个级别的链条" tabindex="-1"><a class="header-anchor" href="#连接多个级别的链条" aria-hidden="true">#</a> 连接多个级别的链条</h2><p>您可以将多个级别的可选链链接在一起，以深入了解模型中更深处的属性、方法和下标。然而，多个级别的可选链不会为返回的值添加更多级别的可选性。</p><p>换句话说：</p><ul><li>如果您试图检索的类型不是可选的，它将因可选的链而成为可选的。</li><li>如果您试图检索的类型<em>已经</em>是可选的，它不会因为链而<em>变得更加</em>可选。</li></ul><p>因此：</p><ul><li>如果您尝试通过可选链检索<code>Int</code>值，则为<code>Int?</code>无论使用多少级别的链条，总是会返回。</li><li>同样，如果您尝试检索<code>Int?</code>通过可选链获得价值，一个<code>Int?</code>无论使用多少级别的链条，总是会返回。</li></ul><p>下面的示例试图访问<code>john``address</code>属性的<code>street</code>财产。这里<em>有两个</em>级别的可选链条，用于链穿<code>residence</code>和<code>address</code>属性，两者都是可选类型：</p><ol><li>if let johnsStreet = john.residence?.address?.street {</li><li>​ print(&quot;John&#39;s street name is (johnsStreet).&quot;)</li><li>} else {</li><li>​ print(&quot;Unable to retrieve the address.&quot;)</li><li>}</li><li>// Prints &quot;Unable to retrieve the address.&quot;</li></ol><p><code>john.residence</code>的值目前包含一个有效的<code>Residence</code>实例。然而，<code>john.residence.address</code>的价值目前为<code>nil</code>。因此，给<code>john.residence?.address?.street</code>的电话失败了。</p><p>请注意，在上面的示例中，您正在尝试检索<code>street</code>属性的值。此属性的类型是<code>String?</code>。因此，<code>john.residence?.address?.street</code>的返回值也是<code>String?</code>，尽管除了属性的基础可选类型外，还应用了两个级别的可选链。</p><p>如果您将实际<code>Address</code>实例设置为<code>john.residence.address</code>的值，并为地址的<code>street</code>属性设置实际值，您可以通过多级可选链访问<code>street</code>属性的值：</p><ol><li>let johnsAddress = Address()</li><li>johnsAddress.buildingName = &quot;The Larches&quot;</li><li>johnsAddress.street = &quot;Laurel Street&quot;</li><li>john.residence?.address = johnsAddress</li><li></li><li>if let johnsStreet = john.residence?.address?.street {</li><li>​ print(&quot;John&#39;s street name is (johnsStreet).&quot;)</li><li>} else {</li><li>​ print(&quot;Unable to retrieve the address.&quot;)</li><li>}</li><li>// Prints &quot;John&#39;s street name is Laurel Street.&quot;</li></ol><p>在本例中，设置<code>john.residence``address</code>属性的尝试将成功，因为<code>john.residence</code>的值目前包含一个有效的<code>Residence</code>实例。</p><h2 id="具有可选返回值的方法链" tabindex="-1"><a class="header-anchor" href="#具有可选返回值的方法链" aria-hidden="true">#</a> 具有可选返回值的方法链</h2><p>前面的示例展示了如何通过可选链检索可选类型属性的值。您还可以使用可选链调用返回可选类型值的方法，并在需要时链上该方法的返回值。</p><p>The example below calls the <code>Address</code> class’s <code>buildingIdentifier()</code> method through optional chaining. This method returns a value of type <code>String?</code>. As described above, the ultimate return type of this method call after optional chaining is also <code>String?</code>:</p><ol><li>if let buildingIdentifier = john.residence?.address?.buildingIdentifier() {</li><li>​ print(&quot;John&#39;s building identifier is (buildingIdentifier).&quot;)</li><li>}</li><li>// Prints &quot;John&#39;s building identifier is The Larches.&quot;</li></ol><p>如果您想对此方法的返回值执行进一步的可选链式，请在方法的括号<em>后</em>放置可选链问号：</p><ol><li>if let beginsWithThe =</li><li>​ john.residence?.address?.buildingIdentifier()?.hasPrefix(&quot;The&quot;) {</li><li>​ if beginsWithThe {</li><li>​ print(&quot;John&#39;s building identifier begins with &quot;The&quot;.&quot;)</li><li>​ } else {</li><li>​ print(&quot;John&#39;s building identifier doesn&#39;t begin with &quot;The&quot;.&quot;)</li><li>​ }</li><li>}</li><li>// Prints &quot;John&#39;s building identifier begins with &quot;The&quot;.&quot;</li></ol><p>注意</p><p>In the example above, you place the optional chaining question mark <em>after</em> the parentheses, because the optional value you are chaining on is the <code>buildingIdentifier()</code> method’s return value, and not the <code>buildingIdentifier()</code> method itself.</p>',38);function O(A,S){const d=n("ExternalLinkIcon");return c(),s("div",null,[a,o("p",null,[e("正如"),o("a",u,[e("可选链作为强制打开包装的替代方案"),t(d)]),e("所示，您可以使用可选链访问可选值上的属性，并检查该属性访问是否成功。")]),h,o("p",null,[e("此方法没有指定返回类型。然而，没有返回类型的函数和方法具有隐式返回类型为"),m,e("，如《"),o("a",p,[e("没有返回值的函数》"),t(d)]),e("中所述。这意味着它们返回一个值"),f,e("或一个空元组。")]),b,o("p",null,[e("如果您尝试通过可选链设置属性，也是如此。上面"),o("a",q,[e("通过可选链访问属性"),t(d)]),e("中的示例试图为"),g,e("设置"),R,e("值，即使"),j,e("属性为"),v,e("。任何通过可选链设置属性的尝试都会返回"),_,e("类型的值，这使您能够与"),w,e("进行比较，看看属性是否已成功设置：")]),I])}const P=l(r,[["render",O],["__file","25.swift-optional-chaining.html.vue"]]);export{P as default};
