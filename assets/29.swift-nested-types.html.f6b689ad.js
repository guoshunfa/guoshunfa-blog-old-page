import{_ as t,r as d,o as l,c as a,a as o,b as e,d as s,e as c}from"./app.4659d0e0.js";const n={},r=c('<h1 id="swift基础-嵌套类型" tabindex="-1"><a class="header-anchor" href="#swift基础-嵌套类型" aria-hidden="true">#</a> Swift基础 - 嵌套类型</h1><p>翻译自：https://docs.swift.org/swift-book/LanguageGuide/NestedTypes.html</p><p>创建枚举通常是为了支持特定类或结构的功能。同样，可以方便地定义纯属实用程序类和结构，以便在更复杂类型的上下文中使用。为了做到这一点，Swift使您能够定义<em>嵌套类型</em>，从而在它们支持的类型的定义中嵌套支持枚举、类和结构。</p><p>要将类型嵌套在另一种类型中，请在它支持的类型的外部大括号中写入其定义。类型可以嵌套到所需的任意级别。</p><h2 id="嵌套类型在行动" tabindex="-1"><a class="header-anchor" href="#嵌套类型在行动" aria-hidden="true">#</a> 嵌套类型在行动</h2><p>下面的示例定义了一个名为<code>BlackjackCard</code>结构，该结构模拟了二十一点游戏中使用的扑克牌。<code>BlackjackCard</code>结构包含两种嵌套枚举类型，称为<code>Suit</code>和<code>Rank</code>。</p><p>在二十一点中，Ace卡的价值为1或11。此功能由一个名为<code>Values</code>结构表示，该结构嵌套在<code>Rank</code>枚举中：</p><ol><li>struct BlackjackCard {</li><li></li><li>​ // nested Suit enumeration</li><li>​ enum Suit: Character {</li><li>​ case spades = &quot;♠&quot;, hearts = &quot;♡&quot;, diamonds = &quot;♢&quot;, clubs = &quot;♣&quot;</li><li>​ }</li><li></li><li>​ // nested Rank enumeration</li><li>​ enum Rank: Int {</li><li>​ case two = 2, three, four, five, six, seven, eight, nine, ten</li><li>​ case jack, queen, king, ace</li><li>​ struct Values {</li><li>​ let first: Int, second: Int?</li><li>​ }</li><li>​ var values: Values {</li><li>​ switch self {</li><li>​ case .ace:</li><li>​ return Values(first: 1, second: 11)</li><li>​ case .jack, .queen, .king:</li><li>​ return Values(first: 10, second: nil)</li><li>​ default:</li><li>​ return Values(first: self.rawValue, second: nil)</li><li>​ }</li><li>​ }</li><li>​ }</li><li></li><li>​ // BlackjackCard properties and methods</li><li>​ let rank: Rank, suit: Suit</li><li>​ var description: String {</li><li>​ var output = &quot;suit is (suit.rawValue),&quot;</li><li>​ output += &quot; value is (rank.values.first)&quot;</li><li>​ if let second = rank.values.second {</li><li>​ output += &quot; or (second)&quot;</li><li>​ }</li><li>​ return output</li><li>​ }</li><li>}</li></ol><p><code>Suit</code>枚举描述了四套常见的扑克牌套装，以及代表其符号的原始<code>Character</code>值。</p><p><code>Rank</code>枚举描述了13个可能的扑克牌排名，以及表示其面值的原始<code>Int</code>值。（此原始<code>Int</code>值不用于Jack、Queen、King和Ace卡。）</p><p>如上所述，<code>Rank</code>枚举定义了自己的进一步嵌套结构，称为<code>Values</code>。这种结构概括了一个事实，即大多数卡片只有一个值，但Ace卡有两个值。<code>Values</code>结构定义了两个属性来表示这一点：</p><ul><li><code>first</code>，类型<code>Int</code></li><li><code>second</code>，类型为<code>Int?</code>，或“optional <code>Int</code>”</li></ul><p><code>Rank</code>还定义了一个计算属性，即<code>values</code>，它返回<code>Values</code>结构的实例。此计算属性考虑卡的排名，并根据排名使用适当的值初始化一个新的<code>Values</code>实例。它为<code>jack</code>、<code>queen</code>、<code>king</code>和<code>ace</code>使用特殊值。对于数字卡，它使用排名的原始<code>Int</code>值。</p><p><code>BlackjackCard</code>结构本身有两个属性——<code>rank</code>和<code>suit</code>。它还定义了一个名为<code>description</code>计算属性，该属性使用<code>rank</code>和<code>suit</code>中存储的值来构建卡片名称和值的描述。<code>description</code>属性使用可选绑定来检查是否有第二个值要显示，如果是，则为第二个值插入额外的描述细节。</p>',14),u=o("code",null,"BlackjackCard",-1),p={href:"https://docs.swift.org/swift-book/LanguageGuide/Initialization.html#ID214",target:"_blank",rel:"noopener noreferrer"},k=o("code",null,"theAceOfSpades",-1),h=c('<ol><li>let theAceOfSpades = BlackjackCard(rank: .ace, suit: .spades)</li><li>print(&quot;theAceOfSpades: (theAceOfSpades.description)&quot;)</li><li>// Prints &quot;theAceOfSpades: suit is ♠, value is 1 or 11&quot;</li></ol><p>即使<code>Rank</code>和<code>Suit</code>嵌套在<code>BlackjackCard</code>中，它们的类型可以从上下文中推断出来，因此此实例的初始化只能通过它们的大小写名称（<code>.ace</code>和<code>.spades</code>）来引用枚举案例。在上面的示例中，<code>description</code>属性正确地报告黑桃王牌的值为<code>1</code>或11。</p><h2 id="提及嵌套类型" tabindex="-1"><a class="header-anchor" href="#提及嵌套类型" aria-hidden="true">#</a> 提及嵌套类型</h2><p>要在其定义上下文之外使用嵌套类型，请在其名称前加上嵌套在其中的类型名称：</p><ol><li>let heartsSymbol = BlackjackCard.Suit.hearts.rawValue</li><li>// heartsSymbol is &quot;♡&quot;</li></ol><p>对于上面的例子，这使<code>Suit</code>、<code>Rank</code>和<code>Values</code>的名称可以故意保持简短，因为它们的名字自然会被定义它们的上下文所限定。</p>',6);function f(_,q){const i=d("ExternalLinkIcon");return l(),a("div",null,[r,o("p",null,[e("由于"),u,e("是一个没有自定义初始化器的结构，因此它有一个隐式成员初始化器，如"),o("a",p,[e("结构类型的成员初始化器"),s(i)]),e("中所述。您可以使用此初始化器初始化名为"),k,e("的新常量：")]),h])}const S=t(n,[["render",f],["__file","29.swift-nested-types.html.vue"]]);export{S as default};
